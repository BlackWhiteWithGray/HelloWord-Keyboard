#include "common_inc.h"
#include "Platform/Sensor/Encoder/encoder.h"
#include "Platform/Driver/driver.h"
#include "Ctrl/Motor/motor.h"
#include "eink_290_bw.h"
#include "rgb_light.h"
#include "Ctrl/Motor/knob.h"
#include "U8g2lib.hpp"
#include "usart.h"
#include "usbd_cdc_if.h"
#include "stm32f4xx_hal.h"
/* User Variables ---------------------------------------------------------*/
BoardConfig_t boardConfig;
SSD1306 oled(&hi2c1);
Eink290BW eink;
Timer timerCtrlLoop(&htim7, 5000);
Encoder encoder(&hspi1);
Driver driver(12);
Motor motor = Motor(7);
RGB rgb(&hspi3);
KnobSimulator knob;
extern DMA_HandleTypeDef hdma_usart2_tx;
uint8_t choose = 0;
uint8_t mode = 0;
static const unsigned char BrightIcon[] = {
        0x00,0xC0,0x03,0x00,0x00,0xE0,0x07,0x00,0x00,0xE0,0x07,0x00,0x60,0xC0,0x03,0x06,0xF0,0x00,0x00,0x0F,0xF0,0x00,0x00,0x0F,0x60,0x00,0x00,0x06,0x00,0xE0,0x07,0x00,0x00,0xF8,0x1F,0x00,0x00,0xFC,0x3F,0x00,0x00,0xFE,0x7F,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x86,0xFF,0xFF,0x61,0x8F,0xFF,0xFF,0xF1,
        0x8F,0xFF,0xFF,0xF1,0x8F,0xFF,0xFF,0xF1,0x8F,0xFF,0xFF,0xF1,0x86,0xFF,0xFF,0x61,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFE,0x7F,0x00,0x00,0xFC,0x3F,0x00,0x00,0xF8,0x1F,0x00,0x60,0x00,0x00,0x06,0xF0,0x00,0x00,0x0F,0xF0,0x00,0x00,0x0F,0x60,0x00,0x00,0x06,0x00,0xC0,0x03,0x00,0x00,0xE0,0x07,0x00,
        0x00,0xE0,0x07,0x00,0x00,0xC0,0x03,0x00
};
static const unsigned char BrightIconRev[] = {
        0xFF,0x3F,0xFC,0xFF,0xFF,0x1F,0xF8,0xFF,0xFF,0x1F,0xF8,0xFF,0x9F,0x3F,0xFC,0xF9,0x0F,0xFF,0xFF,0xF0,0x0F,0xFF,0xFF,0xF0,0x9F,0xFF,0xFF,0xF9,0xFF,0x1F,0xF8,0xFF,0xFF,0x07,0xE0,0xFF,0xFF,0x03,0xC0,0xFF,0xFF,0x01,0x80,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0x79,0x00,0x00,0x9E,0x70,0x00,0x00,0x0E,
        0x70,0x00,0x00,0x0E,0x70,0x00,0x00,0x0E,0x70,0x00,0x00,0x0E,0x79,0x00,0x00,0x9E,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x01,0x80,0xFF,0xFF,0x03,0xC0,0xFF,0xFF,0x07,0xE0,0xFF,0x9F,0xFF,0xFF,0xF9,0x0F,0xFF,0xFF,0xF0,0x0F,0xFF,0xFF,0xF0,0x9F,0xFF,0xFF,0xF9,0xFF,0x3F,0xFC,0xFF,0xFF,0x1F,0xF8,0xFF,
        0xFF,0x1F,0xF8,0xFF,0xFF,0x3F,0xFC,0xFF
};
static const unsigned char VolumeIcon[] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x0F,0x00,0x00,0x80,0x0F,0x00,0x00,0xC0,0x0D,0x04,0x00,0xE0,0x0C,0x0C,0x00,0x70,0x0C,0x1C,0x00,0x38,0x4C,0x38,0x00,0x18,0x4C,0x38,0x00,0x1C,0xCC,0x39,0xFE,0x0F,0xCC,0x33,0xFE,0x07,0x8C,0x73,0xFE,0x03,0x0C,0x73,0xC6,0x03,0x0C,0x67,0xC6,0x03,0x0C,0x67,
        0xC6,0x03,0x0C,0x66,0xC6,0x03,0x0C,0x66,0xC6,0x03,0x0C,0x67,0xC6,0x03,0x0C,0x67,0xFE,0x03,0x0C,0x73,0xFE,0x07,0x8C,0x73,0xFE,0x0F,0xCC,0x33,0x00,0x1C,0xCC,0x39,0x00,0x18,0x4C,0x38,0x00,0x38,0x4C,0x38,0x00,0x70,0x0C,0x1C,0x00,0xE0,0x0C,0x0C,0x00,0xC0,0x0D,0x04,0x00,0x80,0x0F,0x00,0x00,0x00,0x0F,0x00,
        0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00
};
static const unsigned char VolumeIconRev[] = {
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF1,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0x7F,0xF0,0xFF,0xFF,0x3F,0xF2,0xFB,0xFF,0x1F,0xF3,0xF3,0xFF,0x8F,0xF3,0xE3,0xFF,0xC7,0xB3,0xC7,0xFF,0xE7,0xB3,0xC7,0xFF,0xE3,0x33,0xC6,0x01,0xF0,0x33,0xCC,0x01,0xF8,0x73,0x8C,0x01,0xFC,0xF3,0x8C,0x39,0xFC,0xF3,0x98,0x39,0xFC,0xF3,0x98,
        0x39,0xFC,0xF3,0x99,0x39,0xFC,0xF3,0x99,0x39,0xFC,0xF3,0x98,0x39,0xFC,0xF3,0x98,0x01,0xFC,0xF3,0x8C,0x01,0xF8,0x73,0x8C,0x01,0xF0,0x33,0xCC,0xFF,0xE3,0x33,0xC6,0xFF,0xE7,0xB3,0xC7,0xFF,0xC7,0xB3,0xC7,0xFF,0x8F,0xF3,0xE3,0xFF,0x1F,0xF3,0xF3,0xFF,0x3F,0xF2,0xFB,0xFF,0x7F,0xF0,0xFF,0xFF,0xFF,0xF0,0xFF,
        0xFF,0xFF,0xF1,0xFF,0xFF,0xFF,0xFF,0xFF
};
static const unsigned char MoveIcon[] = {
        0x00,0x80,0x01,0x00,0x00,0xC0,0x03,0x00,0x00,0xE0,0x07,0x00,0x00,0xF0,0x0F,0x00,0x00,0xF8,0x1F,0x00,0x00,0xFC,0x3F,0x00,0x00,0xC0,0x03,0x00,0x00,0xC0,0x03,0x00,0x00,0xC0,0x03,0x00,0x00,0xC0,0x03,0x00,0x20,0xC0,0x03,0x04,0x30,0xC0,0x03,0x0C,0x38,0xC0,0x03,0x1C,0x3C,0xC0,0x03,0x3C,0xFE,0xFF,0xFF,0x7F,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0x7F,0x3C,0xC0,0x03,0x3C,0x38,0xC0,0x03,0x1C,0x30,0xC0,0x03,0x0C,0x20,0xC0,0x03,0x04,0x00,0xC0,0x03,0x00,0x00,0xC0,0x03,0x00,0x00,0xC0,0x03,0x00,0x00,0xC0,0x03,0x00,0x00,0xFC,0x3F,0x00,0x00,0xF8,0x1F,0x00,0x00,0xF0,0x0F,0x00,0x00,0xE0,0x07,0x00,
        0x00,0xC0,0x03,0x00,0x00,0x80,0x01,0x00
}
;
static const unsigned char MoveIconRev[] = {
        0xFF,0x7F,0xFE,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x1F,0xF8,0xFF,0xFF,0x0F,0xF0,0xFF,0xFF,0x07,0xE0,0xFF,0xFF,0x03,0xC0,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x3F,0xFC,0xFF,0xDF,0x3F,0xFC,0xFB,0xCF,0x3F,0xFC,0xF3,0xC7,0x3F,0xFC,0xE3,0xC3,0x3F,0xFC,0xC3,0x01,0x00,0x00,0x80,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x80,0xC3,0x3F,0xFC,0xC3,0xC7,0x3F,0xFC,0xE3,0xCF,0x3F,0xFC,0xF3,0xDF,0x3F,0xFC,0xFB,0xFF,0x3F,0xFC,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0x03,0xC0,0xFF,0xFF,0x07,0xE0,0xFF,0xFF,0x0F,0xF0,0xFF,0xFF,0x1F,0xF8,0xFF,
        0xFF,0x3F,0xFC,0xFF,0xFF,0x7F,0xFE,0xFF
};
static const unsigned char PageIcon[] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x87,0xFF,0x3F,0xFC,0x87,0xFF,0x3F,0xFC,0x07,0x00,0x00,0xFC,0x07,0x00,0x00,0xFC,0x07,0x00,0x00,0xFC,0x87,0xFF,0x0F,0xFC,0x87,0xFF,0x0F,0xFC,0x87,0xFF,0x0F,0xFC,0x87,0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0xFC,0x87,0xFF,0x3F,0xFC,0x87,0xFF,0x3F,0xFC,0x87,0xFF,0x3F,0xFC,0x87,0xFF,0x3F,0xFC,0x87,0xFF,0x3F,0xFC,0x87,0xFF,0x3F,0xFC,0x07,0x00,0x00,0xFC,0x07,0x00,0x00,0xFC,0x07,0x00,0x00,0xFC,0x87,0xFF,0x0F,0xFC,0x87,0xFF,0x0F,0xFC,0x87,0xFF,0x0F,0xFC,0x87,0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
static const unsigned char PageIconRev[] = {
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0x78,0x00,0xC0,0x03,0x78,0x00,0xC0,0x03,0xF8,0xFF,0xFF,0x03,0xF8,0xFF,0xFF,0x03,0xF8,0xFF,0xFF,0x03,0x78,0x00,0xF0,0x03,0x78,0x00,0xF0,0x03,0x78,0x00,0xF0,0x03,0x78,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0x03,0x78,0x00,0xC0,0x03,0x78,0x00,0xC0,0x03,0x78,0x00,0xC0,0x03,0x78,0x00,0xC0,0x03,0x78,0x00,0xC0,0x03,0x78,0x00,0xC0,0x03,0xF8,0xFF,0xFF,0x03,0xF8,0xFF,0xFF,0x03,0xF8,0xFF,0xFF,0x03,0x78,0x00,0xF0,0x03,0x78,0x00,0xF0,0x03,0x78,0x00,0xF0,0x03,0x78,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
}
;

/* Thread Definitions -----------------------------------------------------*/
osThreadId_t ctrlLoopTaskHandle;
void ThreadCtrlLoop(void* argument)
{
    motor.AttachDriver(&driver);
    motor.AttachEncoder(&encoder);
    knob.Init(&motor);
    knob.SetEnable(true);
    knob.SetMode(static_cast<KnobSimulator::Mode_t>(mode));


    for (;;)
    {
        // Suspended here until got Notification.
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        knob.Tick();
    }
}

osThreadId_t oledTaskHandle;
void ThreadOledUpdate(void* argument)
{
    uint8_t Color_G = 0;
    uint8_t Trun = 0;

    oled.Init();
    eink.Init();

    oled.Clear();
    oled.drawXBMP( 0, 0, 32, 32, VolumeIcon);
    oled.drawXBMP( 0, 32, 32, 32, BrightIcon);
    oled.drawXBMP( 0, 64,32, 32, MoveIcon);
    oled.drawXBMP( 0, 96,32, 32, PageIcon);
    oled.SendBuffer();
    for (;;)
    {
        oled.SetDrawColor(1);
        oled.SetCursor(0, 0);

        oled.drawXBMP( 0, 0, 32, 32, VolumeIcon);
        oled.drawXBMP( 0, 32, 32, 32, BrightIcon);
        oled.drawXBMP( 0, 64,32, 32, MoveIcon);
        oled.drawXBMP( 0, 96,32, 32, PageIcon);
        oled.drawHVLine(0, choose*32, 32, 1);
        oled.drawHVLine(31, choose*32, 32, 1);
        if(mode>1) {
            switch (choose) {
                case 0:
                    oled.drawXBMP(0, 0, 32, 32, VolumeIconRev);
                    break;
                case 1:
                    oled.drawXBMP(0, 32, 32, 32, BrightIconRev);
                    break;
                case 2:
                    oled.drawXBMP(0, 64, 32, 32, MoveIconRev);
                    break;
                case 3:
                    oled.drawXBMP(0, 96, 32, 32, PageIconRev);
                    break;
            }
        }
        oled.SendBuffer();
        if(Trun)Color_G--;
        else Color_G++;
        if(Color_G==0||Color_G==60)Trun=!Trun;
        //RGB update1`
        for (uint8_t i = 0; i < RGB::LED_NUMBER; i++) { rgb.SetRgbBuffer(i, RGB::Color_t{255, Color_G, 0}, 1); }
        rgb.SyncLights();
    }
}

osThreadId_t peripheralTaskHandle;
void ThreadGpioUpdate(void* argument)
{
    uint8_t message[] = {0xfe,0x00,0x00,0xef};
    for (;;)
    {
        if (HAL_GPIO_ReadPin(KEY_A_GPIO_Port, KEY_A_Pin) == GPIO_PIN_RESET)
        {
            while (HAL_GPIO_ReadPin(KEY_A_GPIO_Port, KEY_A_Pin) == GPIO_PIN_RESET);
            eink.Update();
        }
        if (HAL_GPIO_ReadPin(KEY_B_GPIO_Port, KEY_B_Pin) == GPIO_PIN_RESET)
        {
            while (HAL_GPIO_ReadPin(KEY_B_GPIO_Port, KEY_B_Pin) == GPIO_PIN_RESET);
            if(mode==4) {
                message[1] = 0x08;
                message[2] = 0x00;
                HAL_UART_Transmit(&huart2, (uint8_t *) message, sizeof(message), 1);
            }
            if(mode<2)mode = choose+2;
            else mode=0;
            knob.SetMode(static_cast<KnobSimulator::Mode_t>(mode));
        }
        osDelay(20);
    }
}


/* Timer Callbacks -------------------------------------------------------*/
void OnTimerCallback()
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    // Wake & invoke thread IMMEDIATELY.
    vTaskNotifyGiveFromISR(TaskHandle_t(ctrlLoopTaskHandle), &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}


/* Default Entry -------------------------------------------------------*/
void Main(void)
{
    // Init all communication staff, include USB-CDC/VCP/UART/CAN etc.

    InitCommunication();

    // Init & Run User Threads.
    const osThreadAttr_t controlLoopTask_attributes = {
        .name = "ControlLoopTask",
        .stack_size = 4096,
        .priority = (osPriority_t) osPriorityRealtime, // robot control thread is critical, should be the highest
    };
    ctrlLoopTaskHandle = osThreadNew(ThreadCtrlLoop, nullptr, &controlLoopTask_attributes);

    const osThreadAttr_t oledTask_attributes = {
        .name = "OledTask",
        .stack_size = 4096,
        .priority = (osPriority_t) osPriorityNormal,   // should >= Normal
    };
    oledTaskHandle = osThreadNew(ThreadOledUpdate, nullptr, &oledTask_attributes);

    const osThreadAttr_t peripheralTask_attributes = {
        .name = "peripheralTask",
        .stack_size = 512,
        .priority = (osPriority_t) osPriorityNormal,
    };
    peripheralTaskHandle = osThreadNew(ThreadGpioUpdate, nullptr, &peripheralTask_attributes);

    // Start Timer Callbacks.
    timerCtrlLoop.SetCallback(OnTimerCallback);
    timerCtrlLoop.Start();
}


extern "C"
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef* hspi)
{
    rgb.isRgbTxBusy = false;
}